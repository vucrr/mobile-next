{"ast":null,"code":"import crypto from 'crypto';\nimport fs from 'fs';\nexport var RSAType; // sign with rsa private key\n\n(function (RSAType) {\n  RSAType[RSAType[\"SHA1\"] = 0] = \"SHA1\";\n  RSAType[RSAType[\"SHA256\"] = 1] = \"SHA256\";\n})(RSAType || (RSAType = {}));\n\nexport function rasPrivateKeySign(_ref) {\n  var origin = _ref.origin,\n      privateKeyPath = _ref.privateKeyPath,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? RSAType.SHA1 : _ref$type;\n  var privateKey = fs.readFileSync(privateKeyPath, {\n    encoding: 'utf8'\n  });\n  var algorithm = type === RSAType.SHA1 ? 'RSA-SHA1' : 'RSA-SHA256';\n  var sign = crypto.createSign(algorithm);\n  sign.update(origin, 'utf8');\n  return sign.sign(privateKey, 'base64');\n}\n// verify with rsa public key\nexport function rasPublicKeyVerify(_ref2) {\n  var origin = _ref2.origin,\n      signature = _ref2.signature,\n      publicKeyPath = _ref2.publicKeyPath,\n      _ref2$type = _ref2.type,\n      type = _ref2$type === void 0 ? RSAType.SHA1 : _ref2$type;\n  var publicKey = fs.readFileSync(publicKeyPath, {\n    encoding: 'utf8'\n  });\n  var algorithm = type === RSAType.SHA1 ? 'RSA-SHA1' : 'RSA-SHA256';\n  var verify = crypto.createVerify(algorithm);\n  verify.update(origin, 'utf8');\n  return verify.verify(publicKey, signature, 'base64');\n}\n// encrypt with public key\nexport function publicEncrypt(_ref3) {\n  var publicKeyPath = _ref3.publicKeyPath,\n      toEncrypt = _ref3.toEncrypt;\n  var publicKey = fs.readFileSync(publicKeyPath, {\n    encoding: 'utf8'\n  });\n  var buffer = Buffer.from(toEncrypt);\n  var encrypted = crypto.publicEncrypt(publicKey, buffer);\n  return encrypted.toString('base64');\n}\n// decrypt with private key\nexport function privateDecrypt(_ref4) {\n  var privateKeyPath = _ref4.privateKeyPath,\n      toDecrypt = _ref4.toDecrypt;\n  var privateKey = fs.readFileSync(privateKeyPath, {\n    encoding: 'utf8'\n  });\n  var buffer = Buffer.from(toDecrypt, 'base64');\n  var decrypted = crypto.privateDecrypt(privateKey, buffer);\n  return decrypted.toString('utf8');\n}\n// 3DES 解密 ECB 模式\nexport function DES3ECBDecrypt(_ref5) {\n  var key = _ref5.key,\n      toDecrypt = _ref5.toDecrypt;\n  key = key.padEnd(24, '0');\n  var decipher = crypto.createDecipheriv('des-ede3', key, '');\n  var received = decipher.update(toDecrypt, 'base64', 'utf8');\n  received += decipher.final('utf8');\n  return received;\n}\nexport function md5(message) {\n  var hash = crypto.createHash('md5');\n  hash.update(message);\n  return hash.digest('hex');\n}","map":{"version":3,"sources":["/Users/viser/mobile-next/server/utils/crypto.ts"],"names":["crypto","fs","RSAType","rasPrivateKeySign","origin","privateKeyPath","type","SHA1","privateKey","readFileSync","encoding","algorithm","sign","createSign","update","rasPublicKeyVerify","signature","publicKeyPath","publicKey","verify","createVerify","publicEncrypt","toEncrypt","buffer","Buffer","from","encrypted","toString","privateDecrypt","toDecrypt","decrypted","DES3ECBDecrypt","key","padEnd","decipher","createDecipheriv","received","final","md5","message","hash","createHash","digest"],"mappings":"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","sourcesContent":["import crypto from 'crypto'\nimport fs from 'fs'\n\nexport enum RSAType {\n  SHA1,\n  SHA256,\n}\n\n// sign with rsa private key\ninterface Sign {\n  origin: string\n  privateKeyPath: string\n  type?: number\n}\n\nexport function rasPrivateKeySign({ origin, privateKeyPath, type = RSAType.SHA1 }: Sign): string {\n  const privateKey = fs.readFileSync(privateKeyPath, { encoding: 'utf8' })\n  const algorithm = type === RSAType.SHA1 ? 'RSA-SHA1' : 'RSA-SHA256'\n  const sign = crypto.createSign(algorithm)\n  sign.update(origin, 'utf8')\n  return sign.sign(privateKey, 'base64')\n}\n\ninterface Verify {\n  origin: string\n  signature: string\n  publicKeyPath: string\n  type?: number\n}\n\n// verify with rsa public key\nexport function rasPublicKeyVerify({ origin, signature, publicKeyPath, type = RSAType.SHA1 }: Verify): boolean {\n  const publicKey = fs.readFileSync(publicKeyPath, { encoding: 'utf8' })\n  const algorithm = type === RSAType.SHA1 ? 'RSA-SHA1' : 'RSA-SHA256'\n  const verify = crypto.createVerify(algorithm)\n  verify.update(origin, 'utf8')\n  return verify.verify(publicKey, signature, 'base64')\n}\n\ninterface Encrypt {\n  publicKeyPath: string\n  toEncrypt: string\n}\n\n// encrypt with public key\nexport function publicEncrypt({ publicKeyPath, toEncrypt }: Encrypt): string {\n  const publicKey = fs.readFileSync(publicKeyPath, { encoding: 'utf8' })\n  const buffer = Buffer.from(toEncrypt)\n  const encrypted = crypto.publicEncrypt(publicKey, buffer)\n  return encrypted.toString('base64')\n}\n\ninterface Decrypt {\n  privateKeyPath: string\n  toDecrypt: string\n}\n\n// decrypt with private key\nexport function privateDecrypt({ privateKeyPath, toDecrypt }: Decrypt): string {\n  const privateKey = fs.readFileSync(privateKeyPath, { encoding: 'utf8' })\n  const buffer = Buffer.from(toDecrypt, 'base64')\n  const decrypted = crypto.privateDecrypt(privateKey, buffer)\n  return decrypted.toString('utf8')\n}\n\ninterface DES3Decrypt {\n  key: string\n  toDecrypt: string\n}\n\n// 3DES 解密 ECB 模式\nexport function DES3ECBDecrypt({ key, toDecrypt }: DES3Decrypt): string {\n  key = key.padEnd(24, '0')\n  const decipher = crypto.createDecipheriv('des-ede3', key, '')\n  let received = decipher.update(toDecrypt, 'base64', 'utf8')\n  received += decipher.final('utf8')\n  return received\n}\n\nexport function md5(message: string): string {\n  const hash = crypto.createHash('md5')\n  hash.update(message)\n  return hash.digest('hex')\n}\n"]},"metadata":{},"sourceType":"module"}
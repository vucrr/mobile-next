{"ast":null,"code":"import _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nimport cx from 'classnames';\nimport { Icon } from 'components';\nimport React, { useEffect, useRef, useState } from 'react';\nimport styles from \"./LazyImage.less\";\n\nfunction LazyImage(props) {\n  // 这里解构出 unselectable 是因为 lib 本身有 type bug\n  var src = props.src,\n      className = props.className,\n      unselectable = props.unselectable,\n      imageProps = _objectWithoutProperties(props, [\"src\", \"className\", \"unselectable\"]);\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      loaded = _useState2[0],\n      setLoaded = _useState2[1];\n\n  var ref = useRef(null);\n\n  var fetchImage = function fetchImage(url) {\n    return new _Promise(function (resolve, reject) {\n      var image = new Image();\n      image.src = url;\n      image.onload = resolve;\n      image.onerror = reject;\n    });\n  };\n\n  var loadImage =\n  /*#__PURE__*/\n  function () {\n    var _ref = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(target) {\n      var src;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              src = target.dataset.src;\n\n              if (src) {\n                _context.next = 3;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 3:\n              _context.next = 5;\n              return fetchImage(src);\n\n            case 5:\n              target.src = src;\n              setLoaded(true);\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function loadImage(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  useEffect(function () {\n    var intersection$ = null;\n\n    if ('IntersectionObserver' in window) {\n      var configs = {\n        root: null,\n        rootMargin: '0px',\n        threshold: 0.01\n      };\n\n      var handleIntersection = function handleIntersection(entries) {\n        entries.forEach(\n        /*#__PURE__*/\n        function () {\n          var _ref2 = _asyncToGenerator(\n          /*#__PURE__*/\n          _regeneratorRuntime.mark(function _callee2(entry) {\n            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    if (!(entry.intersectionRatio > 0)) {\n                      _context2.next = 4;\n                      break;\n                    }\n\n                    if (intersection$) intersection$.unobserve(entry.target);\n                    _context2.next = 4;\n                    return loadImage(entry.target);\n\n                  case 4:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2);\n          }));\n\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      };\n\n      intersection$ = new IntersectionObserver(handleIntersection, configs);\n      intersection$.observe(ref.current);\n    } else {\n      void loadImage(ref.current);\n    }\n  }, [src]);\n  return React.createElement(\"div\", {\n    className: cx(className, styles.container)\n  }, !loaded && React.createElement(Icon, {\n    className: styles.placeholder,\n    type: require('svg/placeholder.svg'),\n    size: \"sm\"\n  }), React.createElement(\"img\", _extends({}, imageProps, {\n    className: loaded ? styles.image : styles.imageHidden,\n    ref: ref,\n    \"data-src\": src,\n    src: \"\",\n    alt: \"Xianghuanji\",\n    title: \"Xianghuanji\"\n  })));\n}\n\nexport default LazyImage;","map":{"version":3,"sources":["/Users/viser/mobile-next/src/components/LazyImage/LazyImage.tsx"],"names":["cx","Icon","React","useEffect","useRef","useState","styles","LazyImage","props","src","className","unselectable","imageProps","loaded","setLoaded","ref","fetchImage","url","resolve","reject","image","Image","onload","onerror","loadImage","target","dataset","intersection$","window","configs","root","rootMargin","threshold","handleIntersection","entries","forEach","entry","intersectionRatio","unobserve","IntersectionObserver","observe","current","container","placeholder","require","imageHidden"],"mappings":"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","sourcesContent":["import cx from 'classnames'\nimport { Icon } from 'components'\nimport React, { useEffect, useRef, useState } from 'react'\nimport styles from './LazyImage.less'\n\ninterface LazyImageProps extends React.ImgHTMLAttributes<HTMLImageElement> {}\n\nfunction LazyImage(props: LazyImageProps) {\n  // 这里解构出 unselectable 是因为 lib 本身有 type bug\n  const { src, className, unselectable, ...imageProps } = props\n\n  const [loaded, setLoaded] = useState(false)\n  const ref = useRef(null)\n\n  const fetchImage = (url: string) => {\n    return new Promise((resolve, reject) => {\n      const image = new Image()\n      image.src = url\n      image.onload = resolve\n      image.onerror = reject\n    })\n  }\n\n  const loadImage = async (target: HTMLImageElement) => {\n    const src = target.dataset.src\n    if (!src) return\n    await fetchImage(src)\n    target.src = src\n    setLoaded(true)\n  }\n\n  useEffect(\n    function() {\n      let intersection$: IntersectionObserver | null = null\n      if ('IntersectionObserver' in window) {\n        const configs = {\n          root: null,\n          rootMargin: '0px',\n          threshold: 0.01,\n        }\n        const handleIntersection = (entries: IntersectionObserverEntry[]) => {\n          entries.forEach(async (entry: IntersectionObserverEntry) => {\n            if (entry.intersectionRatio > 0) {\n              if (intersection$) intersection$.unobserve(entry.target)\n              await loadImage(entry.target as HTMLImageElement)\n            }\n          })\n        }\n        intersection$ = new IntersectionObserver(handleIntersection, configs)\n        intersection$.observe(ref.current!)\n      } else {\n        void loadImage(ref.current!)\n      }\n    },\n    [src],\n  )\n\n  return (\n    <div className={cx(className, styles.container)}>\n      {!loaded && <Icon className={styles.placeholder} type={require('svg/placeholder.svg')} size=\"sm\" />}\n      <img\n        {...imageProps}\n        className={loaded ? styles.image : styles.imageHidden}\n        ref={ref}\n        data-src={src}\n        src=\"\"\n        alt=\"Xianghuanji\"\n        title=\"Xianghuanji\"\n      />\n    </div>\n  )\n}\n\nexport default LazyImage\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _regeneratorRuntime from \"@babel/runtime-corejs2/regenerator\";\nimport _objectWithoutProperties from \"@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nimport _asyncToGenerator from \"@babel/runtime-corejs2/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport React from 'react';\nimport Audio from \"./Audio\";\nexport var AudioWidgetStatus;\n\n(function (AudioWidgetStatus) {\n  AudioWidgetStatus[AudioWidgetStatus[\"Loading\"] = 0] = \"Loading\";\n  AudioWidgetStatus[AudioWidgetStatus[\"Loaded\"] = 1] = \"Loaded\";\n  AudioWidgetStatus[AudioWidgetStatus[\"Failed\"] = 2] = \"Failed\";\n  AudioWidgetStatus[AudioWidgetStatus[\"Playing\"] = 3] = \"Playing\";\n  AudioWidgetStatus[AudioWidgetStatus[\"Paused\"] = 4] = \"Paused\";\n})(AudioWidgetStatus || (AudioWidgetStatus = {}));\n\nvar AudioWidget =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(AudioWidget, _React$Component);\n\n  function AudioWidget() {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, AudioWidget);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AudioWidget)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      status: AudioWidgetStatus.Loading\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"audio\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"toggle\", function () {\n      if (!_this.audio) return;\n\n      if (_this.audio.isPlaying) {\n        _this.audio.pause();\n\n        _this.setState({\n          status: AudioWidgetStatus.Paused\n        });\n      } else {\n        _this.audio.play();\n\n        _this.setState({\n          status: AudioWidgetStatus.Playing\n        });\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(AudioWidget, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      void this.loadAudio();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (!this.audio) return;\n      this.audio.stop();\n    } // fix iOS decodeAudioData bug\n    // https://stackoverflow.com/questions/48597747/how-to-play-a-sound-file-safari-with-web-audio-api\n\n  }, {\n    key: \"loadAudio\",\n    value: function () {\n      var _loadAudio = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _this$props, src, config, context, res, buffer, decodedBuffer;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this$props = this.props, src = _this$props.src, config = _objectWithoutProperties(_this$props, [\"src\"]);\n                window.AudioContext = window.AudioContext || window.webkitAudioContext;\n                context = new AudioContext();\n                _context.prev = 3;\n                _context.next = 6;\n                return fetch(src);\n\n              case 6:\n                res = _context.sent;\n                _context.next = 9;\n                return res.arrayBuffer();\n\n              case 9:\n                buffer = _context.sent;\n                _context.next = 12;\n                return AudioWidget.decodeAudioData(context, buffer);\n\n              case 12:\n                decodedBuffer = _context.sent;\n                this.audio = new Audio(decodedBuffer, context, config);\n\n                if (config.autoplay) {\n                  this.audio.play();\n                  this.setState({\n                    status: AudioWidgetStatus.Playing\n                  });\n                } else {\n                  this.setState({\n                    status: AudioWidgetStatus.Loaded\n                  });\n                }\n\n                _context.next = 20;\n                break;\n\n              case 17:\n                _context.prev = 17;\n                _context.t0 = _context[\"catch\"](3);\n                this.setState({\n                  status: AudioWidgetStatus.Failed\n                });\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 17]]);\n      }));\n\n      function loadAudio() {\n        return _loadAudio.apply(this, arguments);\n      }\n\n      return loadAudio;\n    }()\n  }, {\n    key: \"render\",\n    value: function render() {\n      var status = this.state.status;\n      var children = this.props.children;\n      if (status === AudioWidgetStatus.Failed || !this.audio) return null;\n      return children({\n        toggle: this.toggle,\n        status: status\n      });\n    }\n  }], [{\n    key: \"decodeAudioData\",\n    value: function () {\n      var _decodeAudioData = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(context, buffer) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", new _Promise(function (resolve) {\n                  return context.decodeAudioData(buffer, resolve);\n                }));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function decodeAudioData(_x, _x2) {\n        return _decodeAudioData.apply(this, arguments);\n      }\n\n      return decodeAudioData;\n    }()\n  }]);\n\n  return AudioWidget;\n}(React.Component);\n\n_defineProperty(AudioWidget, \"defaultProps\", {\n  autoplay: true,\n  loop: true\n});\n\nexport default AudioWidget;","map":{"version":3,"sources":["/Users/viser/mobile-next/src/components/AudioWidget/AudioWidget.tsx"],"names":["React","Audio","AudioWidgetStatus","AudioWidget","status","Loading","audio","isPlaying","pause","setState","Paused","play","Playing","loadAudio","stop","props","src","config","window","AudioContext","webkitAudioContext","context","fetch","res","arrayBuffer","buffer","decodeAudioData","decodedBuffer","autoplay","Loaded","Failed","state","children","toggle","resolve","Component","loop"],"mappings":"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","sourcesContent":["import React from 'react'\nimport Audio from './Audio'\n\nexport enum AudioWidgetStatus {\n  Loading,\n  Loaded,\n  Failed,\n  Playing,\n  Paused,\n}\n\ntype RequiredProps = {\n  src: string\n  children: (props: { toggle: () => void; status: AudioWidgetStatus }) => React.ReactElement<any>\n}\n\nexport type OptionalConfig = {\n  autoplay: boolean\n  loop: boolean\n}\n\ntype AudioWidgetProps = RequiredProps & Partial<OptionalConfig>\n\nclass AudioWidget extends React.Component<AudioWidgetProps> {\n  static defaultProps = {\n    autoplay: true,\n    loop: true,\n  }\n\n  readonly state = {\n    status: AudioWidgetStatus.Loading,\n  }\n\n  audio: null | Audio = null\n\n  componentDidMount() {\n    void this.loadAudio()\n  }\n\n  componentWillUnmount() {\n    if (!this.audio) return\n    this.audio.stop()\n  }\n\n  // fix iOS decodeAudioData bug\n  // https://stackoverflow.com/questions/48597747/how-to-play-a-sound-file-safari-with-web-audio-api\n  static async decodeAudioData(context: AudioContext, buffer: ArrayBuffer): Promise<AudioBuffer> {\n    return new Promise(resolve => context.decodeAudioData(buffer, resolve))\n  }\n\n  async loadAudio() {\n    const { src, ...config } = this.props\n    window.AudioContext = window.AudioContext || window.webkitAudioContext\n    const context = new AudioContext()\n    try {\n      const res = await fetch(src)\n      const buffer = await res.arrayBuffer()\n      const decodedBuffer = await AudioWidget.decodeAudioData(context, buffer)\n      this.audio = new Audio(decodedBuffer, context, config)\n      if (config.autoplay) {\n        this.audio.play()\n        this.setState({ status: AudioWidgetStatus.Playing })\n      } else {\n        this.setState({ status: AudioWidgetStatus.Loaded })\n      }\n    } catch (e) {\n      this.setState({ status: AudioWidgetStatus.Failed })\n    }\n  }\n\n  toggle = () => {\n    if (!this.audio) return\n    if (this.audio.isPlaying) {\n      this.audio.pause()\n      this.setState({ status: AudioWidgetStatus.Paused })\n    } else {\n      this.audio.play()\n      this.setState({ status: AudioWidgetStatus.Playing })\n    }\n  }\n\n  render() {\n    const { status } = this.state\n    const { children } = this.props\n    if (status === AudioWidgetStatus.Failed || !this.audio) return null\n    return children({ toggle: this.toggle, status })\n  }\n}\n\nexport default AudioWidget\n"]},"metadata":{},"sourceType":"module"}